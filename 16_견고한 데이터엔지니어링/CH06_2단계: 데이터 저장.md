# CH06 2단계: 데이터 저장

---

## 데이터 스토리지 기본 구성 요소

---

- magnetic disk
  - HDD는 물리적 방해를 받음
    - 디스크 용량에 비해 디스크 전송속도가 면적밀도만 증가 됨
    - 탐색 시간이 물리적인 시간이라 오래 걸림
    - 50~500 IOPS
  - 데이터 스토리지 비용이 저렴하기 때문에 많이 사용
  - 데이터 전송 속도는 네트워크 성능에 따라 제한되므로 병렬적으로 디스크에 데이터를 분산할 수 있음
- SSD
  - 플래시 메모리 셀에 데이터를 전하로 저장함
  - 0.1ms미만으로 데이터 조회
  - OLTP 시스템의 표준으로 자리 잡음
  - HDD에 비해 10배 이상의 가격
  - OLAP에서도 캐싱 용도로 고성능 쿼리 지원
- RAM
  - CPU에 연결
  - 휘발성
  - 100ns로 SSD보다 1000배 빠름
  - 캐싱, 데이터 처리, 인덱스 등으로 사용하고 인메모리 DB로 초고성능 읽기 쓰기 등으로도 사용
- 네트워킹과 CPU
  - 성능, 내구성, 가용성을 향상하고자 분산됨
  - RAID와 같이 단일 서버에서 병렬로 동작할 수 있지만, 클라우드 객체 스토리지는 네트워크를 통해 디스크가 분산되고 여러 데이터 센터와 가용 영역에 분산됨
- Serialization
  - 데이터를 평탄화하고 표준 포맷으로 패킹하는 프로세스
- Compression
  - 디스크 공간 절약
  - 검색 속도 향상
  - 네트워크 성능
- 캐싱
  - 자주 접근하거나 최근에 접근한 데이터를 고속 접근 계층에 쌓는 것

## 데이터 스토리지 시스템

---

- 단일 머신 vs 분산 스토리지
  - 데이터를 더 빠르고 대규모로 저장, 검색 및 처리 하고 중복성 기능도 제공
- 최종 일관성 vs 강력한 일관성
  - BASE
    - bsaically available: 일관성을 보장하지는 않지만 최대한 일관된 데이터를 사용
    - soft-state: 트랜잭션이 커밋되었는지 커밋되지 않았는지 불확실
    - eventual consistency(최종 일관성): 어느 시점에 데이터를 읽으면 항상 일관된 값 반환
  - 일관성
    - 강력한 일관성은 정확한 데이터가 필요할 때 사용되지만, 쿼리 지연시간이 길어짐
    - 일관성 단계 설정, 매개변수, 쿼리 수준에서 일관성을 선택할 경우가 생김
- 파일 스토리지
  - 파일은 유한길이, 임의 접근, 바이트 추가 등의 특징을 가짐
  - 객체 스토리지와는 차이점이 있음
  - 로컬 디스크
    - SSD, NTFS
    - 읽기 일관성 지원
  - NAS
    - 네트워크를 통한 스토리지 시스템
    - 일관성 중요
  - 클라우드 파일 시스템 서비스
    - NAS와 비슷하게 동작하지만 자세한 장애 및 구성, 네트워킹은 클라우드가 처리
- 블록 스토리지
  - SSD와 자기 디스크
  - 블록: 디스크에서 지원하는 주소 지정이 가능한 최소 단위
  - RAID
    - Redundant array of independent disk
    - 여러 디스크를 동시에 제어하여 데이터의 내구성을 높이고 성능을 개선
  - 스토리지 영역 네트워크
    - SAN
  - 클라우드 가상화 블록 스토리지
    - EBS
    - SAN과 유사하지만 네트워킹 세부사항을 처리할 필요가 없음
    - 복제본을 두어 가용성도 증대시킴
    - 스냅숏기능도 제공
  - 로컬 인스턴스 볼륨
    - 짧은 지연시간과 높은 IOPS로 호스트 서버에 물리적으로 연결된 블록 스토리지
    - 디스크 장애로 데이터 손실이 될 수 있음
    - EMR에서 임시 스토리지로 데이터 처리할 때 쓰기 좋음
- 객체 스토리지
  - 모든 유형의 파일
  - 한번 쓴 다음에는 랜덤쓰기나 덧붙이는 작업을 지원하지 않음
  - 병렬 스트림 쓰기 및 읽기를 지원하고 쓰기는 할당량 제한까지 읽기는 가상머신의 성능에 따라 대용량으로 확장 가능
  - 병렬 분산된 쿼리 엔진에 데이터를 전달하는 데 이상적
  - 대량의 데이터를 갱신하는 작업에 최적
  - Write Once Read More가 운영 표준이었지만, 데이터 버전과 파일 관리의 복잡성을 극복한 hudi, delta lake같은 시스템이 등장
  - 실제로 디렉토리는 없어 트리를 탐색해 도달하지 않음
  - S3는 최종일관성이 었으나 **강력한 일관성 모델이 됨**
    - 강력한 일관성을 위한 표준 방법
      - 쓰기
        - 객체를 먼저씀
        - 객체 버전에 대해 반환된 메타데이터를 강력한 일관성의 데이터베이스에 쓴다.
      - 읽기
        - 최신 객체 메타데이터를 가져옴
        - 객체 키를 사용하여 메타데이터를 쿼리하여 최신 메타와 객체 메타와 일치한지 확인
        - 일치할 때 까지 확인
  - 스토리지 클래스 및 계층으로 비용절감을 꾀할 수 있음
  - 로컬 스토리지로 마운트하여 쓸 수 있으나 비용때문에 자주 갱신되지 않는 파일에 적합
- 캐시 및 메모리 기반 스토리지 시스템
  - RAM: 뛰어난 지연 시간과 속도 제공, 데이터 손실에 취약
  - memcached: key-value, 단순한 데이터구조
  - redis: key-value, 목록이나 집합 등의 다소 복잡한 데이터 유형 지원
- HDFS
  - 객체스토리지와 유사하지만 동일한 노드에서 컴퓨팅과 스토리지를 결합하여 차이가 있음
  - 카탈로그는 네임노드에 의해 관리됨
- 스트리밍 스토리지
  - 메시지 큐의 경우 저장된 데이터는 일시적이며 일정 기간이 지나면 사라질 것으로 예상됨
  - 스트리밍은 오랜기간 보관할 수 있고 메시지를 객체스토리지에 저장해 무기한 보관도 할 수 있음
  - 리플레이처럼 특정 데이터의 범위를 가져올 수 있음
  - RDB로도 실시간 분석이 가능하지만 트랜잭션때문에 실시간 분석 어플리케이션에 스트리밍 스토리지가 많이 쓰임
- 인덱스, 파티셔닝 및 클러스터링
  - 기본 테이블키와 외부키에 사용됨
  - 행에서 열로의 진화
    - columnar serialization
    - 필요한 열만 스캔하고 높은 압축률을 얻음
    - 개별 행을 검색할 때 성능은 떨어지지만 변환 집계 통계할 때는 우수함
  - 인덱스부터 파티션 및 클러스터링 까지
    - 테이블을 필드 단위로 나눠 여러 하위 테이블로 분할할 수 있음
    - 필터링 정렬 및 조인할 때 성능이 개선됨
    - 클러스터링하면 파티션 내 데이터를 더 세밀하게 구성함
    - 스노우플레이크 마이크로 파티셔닝
      - micro partition = 압축되지 않은 50 ~ 500 MB 행 집합
      - 유사한 행을 묶으려는 알고리즘 방식으로 동작
      - => 중요한 반복을 보이도록 파티션 분할
      - => 파티션 메타데이터에 행수와 값의 범위를 포함하여 스캔해야할 파티션을 결정함, 메타데이터는 인덱스와 유사한 역할을 함
      - => 하이브리드 컬럼형 스토리지 = 스토리지가 기본적으로 컬럼형이지만 테이블을 작은 행 그룹으로 구분함

## 데이터 엔지니어링 스토리지 개요

---

- 데이터 구성 및 쿼리 패턴
  - 목적 및 사용 사례
  - 갱신 패턴
  - 비용
  - 스토리지와 컴퓨팅 분리
- 데이터 웨어하우스
  - OLAP
  - 데이터 레이크에 데이터를 정리하는데 자주 쓰임
  - 비정형 데이터는 처리하지 못함
- 데이터 레이크
  - 가공되지 않은 원시 형태로 보존된 대규모 저장소
  - 저렴한 스토리지로 대량의 데이터 보관
  - 컴퓨팅과 스토리지의 분리
- 데이터 레이크하우스
  - DW + DL
  - 데이터를 다 저장하되 DW처럼 테이블 및 스키마 질의 기능들을 제공함
  - 데이터브릭스의 델타 레이크
  - **데이터를 객체 스토리지에 저장하고 자동화된 메타데이터 관리, 테이블 이력, 갱신 및 삭제 기능을 제공**
  - 다양한 도구를 메타데이터 계층에 연결해 객체 스토리지에 직접 데이터를 읽을 수 있음
  - hudi, iceberg, deltalake
- 데이터 플랫폼
  - 비정형 사용 사례에 대한 객체 스토리지와의 긴밀한 통합을 강조
  - 작업을 단순화하고 벤더 종속성을 더 강화하는 형태로

## Stream-to-Batch 스토리지 아키텍처

---

- 스트리밍 버퍼와 객체 모두에 대해서 쿼리하는 형태

## 스트리지의 주요 아이디어와 동향

---

- 데이터 카탈로그
  - 데이터 리니지와 관계 표현
  - 데이터 설명
  - 데이터 위치
  - 데이터 카탈로그와 카탈로그 자체의 무결성과 통합되는 데이터 파이프라인과 스토리지 시스템을 설정 및 유지관리 해야 함
    - 카탈로그 애플리케이션 통합: 메타데이터 갱신 및 처리
    - 자동화된 스캔: 메타데이터 수집과 추론
    - 데이터포털 및 소셜 계층: 인터페이스를 통해 데이터 관계를 볼 수 있음
    - 데이터 카탈로그 사용 사례: 조직 간 커뮤니케이션과 협업 감소
- 데이터 공유
  - 신중하게 정의된 권한을 바탕으로 데이터 공유
- 스키마
  - 관계형이 아니여도 이미지 같은 경우 형식, 해상도 등으로 설명 가능
  - 쓰기 스키마
    - 모든 쓰기는 스키마를 준수해야 함
    - 데이터레이크가 스키마 메타스토어를 통합해야 함
    - 적재만 되면 데이터를 쉽게 소비하고 활용 가능
  - 읽기 스키마
    - 데이터를 쓸 때 동적으로 생성됨
    - 데이터를 읽을 때 결정해야 함
    - 유연성은 있으나 소비할 때 어려움 
- 컴퓨팅과 스토리지의 분리
  - 코로케이션
    - 짧은 디스크 읽기와 높은 대역폭 확보
  - 분리
    - 임시성과 확장성
    - 데이터 내구성과 가용성
  - 하이브리드 분리와 코로케이션
    - 멀티티어 캐싱과 하이브리드 객체 스토리지의 두 가지 방식으로 이루어짐
      - 멀티티어 캐싱
        - 쿼리 및 데이터 단계에서 다양한 단계에서 사용하기 위해 로컬 스토리지를 스핀업 함
        - S3 + EMR
          - S3에 있는 데이터를 처리할 때 HDFS에 임시로 올려서 처리한 후 S3에 다시 저장
        - Spark
          - 인메모리를 대용량으로 빌려 빠른 작업 후에 메모리 해제하기
        - Druid
          - SSD를 상요하고 데이터 사본을 하나만 보관함
          - 객체 저장소는 내구성을 유지하는 용도로 사용
        - 하이브리드 객체 스토리지
          - colossus
          - 깔끔한 추상화와 컴퓨팅 및 스토리지의 공동 배치
  - 무복사 복제
    - zero copy cloning
    - 물리적으로 복사하지 않아도 새로운 가상 복사본이 생성됨
- 데이터 스토리지 수명 주기 및 데이터 보존
  - 데이터의 접근 빈도, 다운스트림
  - 보관 주기 
  - 핫, 웜, 콜드 데이터
  - 고려사항
    - 검색에 드는 시간과 저장비용을 비교해야 함
  - 보존
    - 가치
    - 시간
    - 컴플라이언스
    - 비용
- 싱글테넌트 스토리지와 멀티테넌트 스토리지 비교
  - 각 데이터 스토리즈는 개별적이고 독립적인 스키마, 버킷 구조 및 스토리지와 관련된 모든 것
  - 멀티테넌트는 단일 데이터베이스 내에 여러 테넌트 저장 가능

## 함께 작업할 대상

---

- 다른 팀과 협력해 합리화된 프로세스를 정의해서 팀이 효율적이고 신속하게 협업할 수 있도록 하기


## 드러나지 않는 요소

---

- 보안: 최소권한
- 데이터 관리
  - 카탈로그 메타데이터
  - 객체 저장소의 데이터 버전 관리
  - 개인정보보호
- 데이터 옵스
  - 기존 운영 모니터링 및 데이터 자체 모니터링
  - 시스템 감시
  - 데이터 관찰 및 감시
- 데이터 아키텍처: SLA, 업스트림 다운스트림ㅇ의 이해
- 오케스트레이션
- 소프트웨어 엔지니어링
