# SEC2 카프카 기본 개념 설명

---

## 2-1 오픈소스 아파치 카프카 생태계

![카프카 생태계](https://miro.medium.com/max/1400/0*z3nQB8zQjQCRhrDG.png)
- 프로듀서: 데이터를 넣는 역할
- 컨슈머: 데이터를 가져가는 역할
- 스트림즈: 토픽에 저장하는 데이터를 처리하여 다시 토픽으로 집어넣는 역할
- 커넥트: 데이터 파이프라인을 운영하는 툴. 소스=producer, 싱크=consumer **클러스터 형태로 운영하고 템플릿 형태로 반복적으로 사용**하는 점이 특징

---

## 2-2 카프카 브로커와 클러스터

---

![카프카 주키퍼 브로커](https://miro.medium.com/max/890/1*_QgMuJgHTnKa1i5ZMTRsYQ.png)
- 주키퍼:카프카 클러스터를 운영하기 위해 필요한 어플리케이션
- 카프카 클러스터
  - 여러개의 브로커가 존재
  - 브로커
    - 하나의 프로세스임
    - 데이터를 주고받기 위해 사용하는 주체
    - 하나의 서버에는 한 개의 브로커 프로세스가 실행
    - 3대 이상의 브로커 서버를 하나의 클러스터로 묶어 운영하여 분산 저장하고 복제함

## 2-3 카프카 클러스터와 주키퍼

---

- 여러개의 클러스터를 주키퍼 앙상블과 연결하여 사용할 수 있음
- root znode에 각 클러스터별 znode를 생성하고 클러스터 실행시 root가 아닌 하위 znode로 설정
- 3.0부터는 주키퍼가 없어도 클러스터 동작 가능. 아직 안정성 검증은 안됨

## 2-4 카프카 브로커의 역할

- 컨트롤러
  - 브로커의 상태 체크하고 브로커의 문제가 생기면 리더 파티션을 재분배함.
  - 클러스터 장애 브로커를 빨리 빼고 다른 브로커가 대체하는 것이 중요
- 데이터 삭제
  - 오직 브로커만이 log segment 단위로 데이터를 삭제하게 됨
  - 시간이나 용량, compact 등 특정 기준으로 브로커가 데이터를 삭제함
- 컨슈머 오프셋 저장
  - 파티션의 어느 레코드까지 가져갔는지 확인하기 위해 **오프셋을 커밋**함
  - `__counsumer_offests` intenal토픽으로 자동생성되어 오프셋이 저장됨
- 그룹 코디네이터
  - 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할
  - 파티션과 컨슈머는 기본적으로 1대1이나 장애 발생시 **rebalancing**함

## 2-5 브로커 로그와 세그먼트

- 데이터 저장
  - `config/server.properties`의 `log.dir`옵션에 정의한 디렉토리에 데이터를 저장
  - 토픽이름과 파티션 번호의 조합으로 폴더가 생성됨 ex) hello.kafka-0
  - ![카프카 로그 예시](https://t1.daumcdn.net/cfile/tistory/993BBD4A5C87C9552C)
  - log: 메시지와 메타데이터 저장
  - index: 메시지의 오프셋을 인덱싱한 정보를 담은 파일
  - timeindex: 메시지에 포함된 timestamp값을 기준으로 인덱싱한 정보
- 로그와 세그먼트
  - 세그먼트 크기나 경과시간에 따라 log파일이 분리됨
    - log.segment.bytes: 바이트단위의 최대 세그먼트 크기 지정. 기본 값 1GB
    - log.roll.ms(hours): 세그먼트가 싱규 생성된 이후 다음 파일로 넘어가는 시간 주기. 기본 값은 7일
  - **offset은 레코드의 고유한 위치**고, 파일명에 세그먼트의 첫 Offset 기준으로 작성됨
  - 가장 마지막 세그먼트(쓰기가 일어나고 있는)는 **액티브 세그먼트**. 액티브 세그먼트는 삭제 대상에 포함되지 않음
  - 다른 세그먼트는 retention 옵션에 따라 삭제 대상으로 지정

## 2-6 세그먼트와 삭제 주기(cleanup.policy)

---

- cleanup.policy=delete
  - 브로커가 파티션을 체크하여 delete를 진행함
    - retention.ms(minutes, hours): 세그먼트를 보유할 최대 기간. 기본 값은 7일
    - retention.bytes: 파티션당 로그 적재 바이트 값. 기본 값은 -1 (지정하지 않음)
    - log.retention.check.interval.ms: 세그먼트가 삭제 영역에 들어왔는지 확인하는 간격. 기본 값은 5분
  - 데이터는 레코드 단위가 아닌 **세크먼트 단위로 삭제**됨. 레코드별 수정/삭제는 불가
  - 데이터 검증이 필요할 때는 producer/consumer에서 수행하는 것을 권장
- cleanup.policy=compact
  - ![compact예시](https://miro.medium.com/max/624/1*zJfxuBfEw-OrRM6qEpmpzQ.png)
  - 토픽 압축: 메시지 키 별로 해당 메시지 중의 최신 데이터만 남겨두고 나머지는 삭제
  - 액티브 세그먼트를 제외한 데이터가 대상이고, 일부 레코드만 삭제 될 수 있음
  - tail 영역: 압축이 완료된 레코드로, clean log라고 함
  - head 영역: 압축 되기 전 레코드로, dirty log라고 함
  - `min.cleanable.dirty.ratio`: 데이터의 압축 시작 지점으로, tail/head의 비율을 뜻함. 예를 들어 0.5일경우 tail과 head와 레코드 개수가 동일할 경우 압축이 실행 됨. 0.1일 경우 압축이 자주 일어나 최신 데이터 유지만 가능하지만 broker에 부담을 줌

## 2-7 복제(replication)

---

- replication은 fault tolerant system으로 동작하도록 함
- 카프카의 데이터 복제는 **파티션 단위**로 이루어짐
- replication factor는 파티션의 복제 개수로, 1(복제 없음) ~ 브로커 개수만큼 설정하여 사용 가능
- leader와 follower로 구성
  - leader는 P, C와 직접 통신
  - follower 복제데이터를 가지고 있음
  - follower는 leader의 Offset을 확인하여 자신의 파티션에 데이터를 저장하는 것을 **복제**라고 함
- 복제 개수만큼 저장 용량이 증가함. 하지만 안정성의 장점때문에 2 이상의 복제 개수를 정하는 것이 좋음
- 데이터가 일부 유실되어도 무관하고 처리속도가 중요(네비게이션 GPS 데이터)하면 1로하고 유실이 일어나지 않을려면(금융) 3으로 운영함
- leader가 장애가 나면 follower가 leader로 승급함 

## 2-8 ISR(In-Synce-Replicas)

---

- ISR은 leader와 follower가 offset이 같다는 뜻. 모든 데이터가 복제된 상태
- ISR되지 않은 follower를 리더로 승급하면 데이터가 유실될 수 있음
  - unclean.leader.election.enable=true => 유실 감수
  - unclean.leader.election.enable=false => 해당 브로커가 복구될 때까지 중단


## 2-9 토픽과 파티션

---

- 토픽
  - 데이터를 구분하기 위해 사용하는 단위
  - 1개 이상의 파티션
- 파티션
  - queue의 fifo 구조. 하지만 pop과 달리 삭제하지 않아 여러 컨슈머 그룹들이 여러번 가져갈 수 있음
  - record가 저장됨
- 토픽 생성시 파티션이 배치 되는 법
  - ![파티션 생성](https://miro.medium.com/max/1396/1*UEjzjKWxqduWnOpIzC34Ow.png)
  - 0번 부터 **round-robin방식으로 leader 파티션들이 생성**됨
  - leader가 P/C와 직접 통신하기 때문에 트래픽 분산 및 선형확장이 가능
  - 특정 브로커에 파티션이 몰릴 경우 `kafka-reassign-partitions.sh`명령으로 파티션 재분배 가능
- 파티션과 컨슈머의 처리량
  - 파티션은 병렬처리의 핵심
  - 하나의 컨슈머는 2개 이상의 파티션을 연결할 수 없음
  - 컨슈머 개수를 스케일 아웃 하는 것이 병렬 처리에 가장 좋음
- **파티션 개수를 줄이는 것은 불가능**
  - 토픽을 삭제하고 재생성하는 방법밖에 없음
  - 폴더를 합치고 timeindex를 취합 정렬 등 하는 과정이 쉽지 않음

## 2-10 레코드

---

- ![레코드사진](https://images.velog.io/images/hyun6ik/post/5bf60734-f205-4d2b-99c0-61fadf33124e/image.png)
- 구성
  - 타임스탬프
    - 스트림 프로세싱에서 활용하기 위한 시간을 저장하는 용도
    - unix timestmap
    - P에서 따로 설정하지 않으면 Producer record create time이 기본값. 또는 브로커 적재 시간(log append time)으로 설정도 가능
    - 옵션은 토픽 단위로 설정 가능하며 `message.timestamp.type`을 사용
  - 오프셋
    - 프로듀서가 생성한 레코드에는 존재하지 않음
    - 0부터 1씩 증가함
    - 오프셋을 기준으로 완료된 데이터와 처리해야할 데이터를 구분
    - 각 메시지는 파티션별로 고유한 오프셋을 가지므로 컨슈머에서 중복처리를 방지하기 위한 수단으로도 활용됨
  - 헤더
    - 레코드의 스키바 버전이나 포맷과 같이 데이터 프로세싱에 참고할만한 정보
  - 메시지 키
    - 처리하고자 하는 메시지 값을 분류하기 위한 용도. **파티셔닝**
    - 어느 파티션에 들어갈지 정하는 것이 partitioner
    - 필수 값은 아니고 지정하지 않으면 null로 설정 됨
    - 해쉬값에 의해서 특정 파티션에 매핑되어 저장됨
  - 메시지 값
    - 실질적으로 처리할 데이터가 담기는 공간
    - 다양한 형태로 지정 가능. 일반적으로는 string serializer, deserializer로 json 형태의 데이터를 활용함
    - 컨슈머는 미리 역직렬화 포맷을 알고 있어야 함

## 2-11 유지보수하기 좋은 토픽 이름 정하기

---

- 제약 조건
  - 빈 문자열 토픽 이은 지원하지 않음
  - `.` `_`가 동시에 못 들어감
  - 이것은 직접 생성할 때 보면 될듯
- 작명 방법
  - 토픽 이름은 데이터의 얼굴!!
  - 토픽 이름 변경을 지원하지 않음
- 작명의 템플릿과 예시
  - <환경>.<팀명>.<어플리케이션 명>.<메시지 타입>: prd.marketing.sms-platfomr.json
  - <프로젝트명>.<서비스명>.<환경>.<이벤트명>: commerce.payment.prd.notification
  - <환경>.<서비스명>.<Jira번호>.<메시지타입>: dev.email-sender.jira-1234.email-vo-custom
  - <카프카-클러스터-명>.<환경>.<서비스명>.<메시지타입>: aws-kafka.live.marketing-platform.json

## 2-12 클라이언트 메타데이터와 브로커 통신

---

- 클라이언트 메타데이터
  - 카프카 클라이언트는 **리더 파티션의 위치**를 알기 위해 메타데이터를 브로커로부터 전달 받음
  - 메타데이터 옵션
    - metadata.max.age.ms: 메타데이터를 강제로 리프레쉬하는 간격. 기본값은 5분
    - metadata.max.idle.ms: P가 유휴상태일 경우 메타데이터를 캐시에 유지하는 기간. 프로듀서가 데이터 보낸후 경과한 시간. 기본값은 5분
- 메타데이터 이슈가 발생한 경우 `LEADER_NOT_AVAILABL` exception이 발생
  - 리더 파티션이 없어서 발생하며 대부분 메타데이터 리프레쉬 이슈임

## 퀴즈

---

- 1) 컨슈머가 가져간 데이터는 파티션에서 삭제된다
  - X 브로커가 compact와 delete로 삭제됨
- 2) 카프카에서 데이터 복제의 단위는 토픽이다
  - X 파티션
- 3) 파티션은 1개의 리더 파티션과 1개 이상의 팔로워 파티션으로 이루어져 있다
  - X replication factor가 1인 경우 리더만 있음
- 4) 프로듀서와 컨슈머는 팔로워 파티션과 통신하여 데이터 처리량을 늘릴 수 있다
  - X 반드시 리더와만 통신
- 5) 레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋으로 이루어져 있다
  - X 헤더
- 6) 다음 파티션에서 압축(compat)실행 된다면, 남은 모든 오프셋의 배열은?
  - ![문제](https://cdn.inflearn.com/public/files/courses/327041/units/111387/3b30c6fa-a62b-4894-a09d-65a642168583/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2010.27.16.png)
  - 10 14 15 16 17 18 19